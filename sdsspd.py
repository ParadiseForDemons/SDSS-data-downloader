# -*- coding: utf-8 -*-
"""SDSSPD.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RH9v4wYBosnHy5aytLQHPuD1_Is8aCTl
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install numpy tqdm Pillow requests astroquery astropy pandas

#!/usr/bin/env python3
# ==============================================================================
# SDSS Data Downloader
# ==============================================================================
"""
A comprehensive script to download various data types from the Sloan Digital Sky Survey (SDSS).

This tool provides a streamlined, step-by-step interactive interface with robust
input validation for user prompts. Users can fetch:
- Images (with simplified choices for object type and morphology)
- Spectra (requires specific Plate, MJD, and Fiber ID)
- Catalog Data (with simplified choices for common data types or an option for custom SQL)

Downloaded data can be saved in various formats (PNG, FITS, CSV, JSON) to:
- Google Drive (if in Colab environment)
- Google Colab's local /content directory (temporary)
- A custom local path on the user's system
- Directly downloaded to the user's machine (Colab only, for single items)

The script includes robust error handling for Google Drive mounting issues and
data retrieval failures from astronomical services.
"""

import os
import gc
import numpy as np
from tqdm import tqdm
from PIL import Image
import requests
from io import StringIO
import json

# Attempt to import Colab specific modules for Google Drive and direct file downloads
try:
    from google.colab import drive, files
    COLAB_ENV = True
except ImportError:
    COLAB_ENV = False

# Import astronomical libraries
from astroquery.sdss import SDSS
from astropy import units as u
from astropy.coordinates import SkyCoord
from astropy.io import fits
from astropy.table import Table
import pandas as pd # Used for converting Astropy Table to JSON via Pandas DataFrame
from astroquery.skyview import SkyView # Used as an alternative image retrieval service

# --- Constants and Configurations ---
# Default band for image downloads
DEFAULT_IMAGE_BAND = "r"
# Supported SDSS image bands
SUPPORTED_IMAGE_BANDS = ['u', 'g', 'r', 'i', 'z']
# Default image size in pixels
DEFAULT_IMAGE_SIZE = 200
# Base URL for SDSS DR18 spectrum data
SDSS_SPECTRUM_BASE_URL = "http://dr18.sdss.org/optical/spectrum/r/sppParams/final/"
# Base URL for SkyServer SQL queries
SKYSERVER_SQL_BASE_URL = "http://skyserver.sdss.org/dr18/en/tools/search/x_sql.aspx"

# Mapping for object types to SDSS 'type' in PhotoObj
OBJECT_TYPE_MAP_IMAGES = {
    '1': {'name': 'Galaxy', 'sql_condition': 'type = 3'},
    '2': {'name': 'Star', 'sql_condition': 'type = 6'},
    '3': {'name': 'QSO', 'sql_condition': 'type = 1'}, # QSO (Quasar)
    '4': {'name': 'All Common Types', 'sql_condition': 'type IN (1, 3, 6)'} # All common types
}

# Mapping for morphology types for galaxies
MORPHOLOGY_TYPE_MAP = {
    '1': {'name': 'Elliptical-like', 'sql_condition': 'fracDeV_r > 0.8'}, # More de Vaucouleurs-like
    '2': {'name': 'Spiral-like', 'sql_condition': 'fracDeV_r < 0.2'}, # More exponential-like
    '3': {'name': 'All Galaxies (no specific morphology filter)', 'sql_condition': '1=1'} # No specific fracDeV_r filter
}

# Mapping for common catalog data types (for simplified SQL generation)
CATALOG_DATA_MAP = {
    '1': {'name': 'Galaxies (common columns: RA, DEC, Redshift, Magnitudes)',
          'table': 'PhotoObj',
          'columns': 'objid, ra, dec, z, petroMag_u, petroMag_g, petroMag_r, petroMag_i, petroMag_z',
          'where': 'type = 3 AND z > 0'}, # Ensure redshift is positive for galaxies
    '2': {'name': 'Stars (common columns: RA, DEC, Magnitudes)',
          'table': 'PhotoObj',
          'columns': 'objid, ra, dec, petroMag_u, petroMag_g, petroMag_r, petroMag_i, petroMag_z',
          'where': 'type = 6'},
    '3': {'name': 'Quasars (QSOs) (common columns: RA, DEC, Redshift, Magnitudes)',
          'table': 'SpecObj', # QSOs are usually in SpecObj with a spectrum
          'columns': 'objid, ra, dec, z, class, subClass',
          'where': "class = 'QSO'"},
    '4': {'name': 'Custom SQL Query (for advanced users)', 'table': '', 'columns': '', 'where': ''}
}


# ==============================================================================
# DATA RETRIEVAL FUNCTIONS
# ==============================================================================

def get_sdss_image_aq(ra, dec, band, size):
    """
    Fetches an SDSS image using `astroquery.sdss`.

    Args:
        ra (float): Right Ascension in degrees.
        dec (float): Declination in degrees.
        band (str): SDSS filter band (e.g., 'g', 'r', 'i').
        size (int): Desired image size in pixels (side length).

    Returns:
        astropy.io.fits.PrimaryHDU: The primary HDU containing image data, or None if retrieval fails.
    """
    try:
        coord = SkyCoord(ra=ra * u.deg, dec=dec * u.deg, frame="icrs")
        # Calculate radius for astroquery.sdss based on desired pixel size.
        # SDSS images have a plate scale of ~0.396 arcsec/pixel.
        radius_arcsec = (size * 0.396 / 2) * u.arcsec

        # `SDSS.get_images` returns a list of `HDUList` objects.
        # We're interested in the primary HDU (index 0) of the first `HDUList`.
        imgs_hdulists = SDSS.get_images(coordinates=coord, band=band, radius=radius_arcsec)

        if not imgs_hdulists:
            return None

        # Iterate through the list of HDULists to find one with valid data in its primary HDU
        for hdulist in imgs_hdulists:
            if hdulist and hdulist[0].data is not None:
                return hdulist[0] # Return the PrimaryHDU object itself
        return None # No suitable HDU found
    except Exception as e:
        # print(f"⚠️ Error fetching image with astroquery.sdss for RA={ra:.2f}, DEC={dec:.2f}: {e}")
        return None

def get_sdss_image_sv(ra, dec, band, size):
    """
    Fetches an SDSS image using `astroquery.skyview`.

    Args:
        ra (float): Right Ascension in degrees.
        dec (float): Declination in degrees.
        band (str): SDSS filter band (e.g., 'g', 'r', 'i').
        size (int): Desired image size in pixels (side length).

    Returns:
        astropy.io.fits.PrimaryHDU: The primary HDU containing image data, or None if retrieval fails.
    """
    try:
        # SkyView survey names for SDSS are typically 'SDSSg', 'SDSSr', etc.
        # Ensure the survey name matches SkyView's expected format.
        survey_name = f'SDSS{band}'.upper() # e.g., 'SDSSG', 'SDSSR'

        # `SkyView.get_images` returns a list of `PrimaryHDU` objects.
        hdus = SkyView.get_images(position=f"{ra} {dec}", survey=survey_name, pixels=(size, size))

        if not hdus:
            return None

        # Find the first HDU that contains valid data
        for hdu in hdus:
            if hdu.data is not None:
                return hdu # Return the PrimaryHDU object directly
        return None # No suitable HDU found
    except Exception as e:
        # print(f"⚠️ Error fetching image with SkyView for RA={ra:.2f}, DEC={dec:.2f}: {e}")
        return None

def get_sdss_spectrum_req(plate, mjd, fiberid):
    """
    Fetches an SDSS spectrum via direct HTTP requests to the SDSS data archive.

    Args:
        plate (int): Plate number.
        mjd (int): Modified Julian Date.
        fiberid (int): Fiber ID.

    Returns:
        bytes: The content of the FITS file as bytes, or None if retrieval fails.
    """
    url = f"{SDSS_SPECTRUM_BASE_URL}spec-{plate:04d}-{mjd}-{fiberid:04d}.fits"
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status() # Raise an HTTPError for bad responses (4xx or 5xx)
        return response.content # Return the binary content of the FITS file
    except requests.exceptions.RequestException as e:
        print(f"⚠️ Error fetching spectrum {plate}-{mjd}-{fiberid}: {e}")
        return None

def get_sdss_catalog_data_req(query):
    """
    Fetches catalog data via direct HTTP requests to the SkyServer SQL API.

    Args:
        query (str): The SQL query string for SkyServer.

    Returns:
        astropy.table.Table: An Astropy Table containing the catalog data, or None if retrieval fails.
    """
    params = {
        "cmd": query,
        "format": "csv" # Requesting CSV format for easier parsing
    }
    try:
        response = requests.get(SKYSERVER_SQL_BASE_URL, params=params, timeout=30) # Longer timeout for potentially large queries
        response.raise_for_status()
        data = StringIO(response.text)
        table = Table.read(data, format='csv')
        return table
    except requests.exceptions.RequestException as e:
        print(f"⚠️ Error fetching catalog data: {e}")
        return None
    except Exception as e:
        print(f"⚠️ Error processing catalog data (likely response format issue): {e}")
        return None

# ==============================================================================
# IMAGE PROCESSING FUNCTIONS
# ==============================================================================

def normalize_png(data, target_size):
    """
    Normalizes image data to the 0-255 range and resizes it for PNG saving.

    Args:
        data (numpy.ndarray): The raw image data (e.g., from FITS).
        target_size (int): The desired square dimension (side length) for the output PNG.

    Returns:
        PIL.Image.Image: A Pillow Image object ready for saving as PNG.
    """
    data_min = np.nanmin(data)
    data_max = np.nanmax(data)

    if data_max == data_min: # Handle cases where data has no variation (e.g., all zeros or NaNs)
        norm = np.zeros_like(data)
    else:
        norm = (data - data_min) / (data_max - data_min)
    norm = np.nan_to_num(norm, nan=0.0) # Replace any NaNs with 0

    # Convert to 8-bit unsigned integer and then to grayscale Pillow image, finally resize
    return Image.fromarray(np.uint8(255 * norm)).convert("L").resize((target_size, target_size))

# ==============================================================================
# HELPER FUNCTIONS FOR SAVING AND DOWNLOADING
# ==============================================================================

def download_images_to_path(ra_decs, band_name, img_size, output_fmt, target_path):
    """
    Handles the loop for downloading SDSS images for provided RA/DEC coordinates.

    Args:
        ra_decs (list of tuple): A list of (RA, DEC) tuples to download images for.
        band_name (str): SDSS filter band for images.
        img_size (int): Desired size in pixels for images.
        output_fmt (int): Output format (1=PNG, 2=FITS, 3=Both).
        target_path (str): Directory path where images will be saved.

    Returns:
        int: The number of images successfully downloaded and saved.
    """
    downloaded_count = 0
    for i, (ra, dec) in tqdm(enumerate(ra_decs), total=len(ra_decs), desc="Downloading Images"):
        hdul = None

        # 1. Try `astroquery.sdss` first as it's the primary SDSS source
        hdul = get_sdss_image_aq(ra, dec, band_name, img_size)

        # 2. If astroquery.sdss fails, try `astroquery.skyview` as an alternative
        if hdul is None:
            hdul = get_sdss_image_sv(ra, dec, band_name, img_size)

        if hdul is None:
            print(f"⚠️ Could not retrieve image data for RA={ra:.2f}, DEC={dec:.2f} from either source.")
            continue # Skip to the next image if both sources fail

        try:
            # Access data from the `PrimaryHDU` object
            data = hdul.data.astype(float)

            if output_fmt in (2, 3): # Save as FITS
                fits_name = os.path.join(target_path, f"image_RA{ra:.2f}_DEC{dec:.2f}.fits") # Use RA/DEC in filename for uniqueness
                # Create a new `HDUList` from the retrieved `PrimaryHDU` and write it to file.
                fits.HDUList([hdul]).writeto(fits_name, overwrite=True)

            if output_fmt in (1, 3): # Save as PNG
                png_name = os.path.join(target_path, f"image_RA{ra:.2f}_DEC{dec:.2f}.png") # Use RA/DEC in filename for uniqueness
                # Only save as PNG if there's variation in the image data to avoid errors
                if np.nanmax(data) - np.nanmin(data) > 0:
                    normalize_png(data, img_size).save(png_name)
                else:
                    print(f"⚠️ Skipping PNG for image at RA={ra:.2f}, DEC={dec:.2f} (data is constant or all NaNs).")

            # Clean up memory
            del data, hdul
            gc.collect()
            downloaded_count += 1
        except Exception as e:
            print(f"⚠️ Error processing/saving image for RA={ra:.2f}, DEC={dec:.2f}: {e}")
    return downloaded_count

def save_single_item(item_data, item_filename, target_path, data_type, output_fmt):
    """
    Saves a single data item (spectrum or catalog) to the specified path.

    Args:
        item_data: The data to save (bytes for spectrum, Astropy Table for catalog, or bytes for JSON catalog).
        item_filename (str): The desired filename for the saved item.
        target_path (str): The directory path where the item will be saved.
        data_type (str): Type of data ('2' for spectrum, '3' for catalog).
        output_fmt (int): The chosen output format (1=CSV, 2=FITS, 3=JSON for catalog).

    Returns:
        int: 1 if saved successfully, 0 otherwise.
    """
    try:
        full_path = os.path.join(target_path, item_filename)
        if data_type == '2': # Spectrum data (expected as bytes)
            with open(full_path, 'wb') as f:
                f.write(item_data)
        elif data_type == '3': # Catalog data (expected as Astropy Table or pre-converted JSON bytes)
            if output_fmt == 1: # CSV
                item_data.write(full_path, format='ascii.csv', overwrite=True)
            elif output_fmt == 2: # FITS
                item_data.write(full_path, format='fits', overwrite=True)
            elif output_fmt == 3: # JSON (item_data is already bytes)
                if isinstance(item_data, bytes):
                    with open(full_path, 'wb') as f:
                        f.write(item_data)
                else: # Fallback if JSON conversion failed upstream for some reason
                    print("⚠️ JSON data not in bytes format for saving. Saving as CSV instead.")
                    item_data.write(full_path.replace(".json", ".csv"), format='ascii.csv', overwrite=True)
            else: # Generic fallback for unexpected catalog format
                print("❌ Invalid format for catalog data, saving as CSV by default.")
                item_data.write(full_path.replace(os.path.splitext(full_path)[1], ".csv"), format='ascii.csv', overwrite=True)

        print(f"✅ {data_type.capitalize()} saved to: {full_path}")
        return 1
    except Exception as e:
        print(f"⚠️ Error saving {data_type}: {e}")
        return 0

# ==============================================================================
# MAIN PROGRAM EXECUTION
# ==============================================================================

def main():
    """
    Main function to run the SDSS Data Downloader interactive process.
    """
    print("🌀 Welcome to the SDSS Data Downloader")
    print("This tool helps you fetch Images, Spectra, or Catalog Data from SDSS.")

    # --- Step 1: Choose Data Type ---
    print("\n--- Step 1: Select Data Type ---")
    print("Which kind of astronomical data do you want to download?")
    print("1. Images (Simplified choices for object type and morphology)")
    print("2. Spectra (Requires specific Plate, MJD, and Fiber ID)")
    print("3. Catalog Data (Simplified choices or custom SQL)")

    data_type_choice = ""
    while data_type_choice not in ['1', '2', '3']:
        data_type_choice = input("Enter your choice (1, 2, or 3): ").strip()
        if data_type_choice not in ['1', '2', '3']:
            print("❌ Invalid input. Please enter 1, 2, or 3.")

    # Initialize variables for user inputs
    ra_decs_list = [] # List to store (RA, DEC) tuples for images
    output_format_choice = None
    image_size = DEFAULT_IMAGE_SIZE
    image_band = DEFAULT_IMAGE_BAND
    plate, mjd, fiberid = None, None, None
    catalog_sql_query = "" # This will be the final SQL query for catalog data

    # --- Step 2: Get Data-Specific Parameters ---
    print("\n--- Step 2: Provide Data-Specific Parameters ---")
    if data_type_choice == '1': # Images
        print("🌌 What type of celestial object images do you want to download?")
        for key, val in OBJECT_TYPE_MAP_IMAGES.items():
            print(f"{key}. {val['name']}")

        object_type_choice = ""
        while object_type_choice not in OBJECT_TYPE_MAP_IMAGES:
            object_type_choice = input(f"Enter your choice ({'/'.join(OBJECT_TYPE_MAP_IMAGES.keys())}): ").strip()
            if object_type_choice not in OBJECT_TYPE_MAP_IMAGES:
                print(f"❌ Invalid input. Please enter one of: {', '.join(OBJECT_TYPE_MAP_IMAGES.keys())}.")

        object_type_sql_condition = OBJECT_TYPE_MAP_IMAGES[object_type_choice]['sql_condition']

        morphology_sql_condition = ""
        if object_type_choice == '1': # If user chose 'Galaxy'
            print("\n💫 For galaxies, do you have a specific morphology in mind?")
            for key, val in MORPHOLOGY_TYPE_MAP.items():
                print(f"{key}. {val['name']}")

            morphology_choice = ""
            while morphology_choice not in MORPHOLOGY_TYPE_MAP:
                morphology_choice = input(f"Enter your choice ({'/'.join(MORPHOLOGY_TYPE_MAP.keys())}): ").strip()
                if morphology_choice not in MORPHOLOGY_TYPE_MAP:
                    print(f"❌ Invalid input. Please enter one of: {', '.join(MORPHOLOGY_TYPE_MAP.keys())}.")

            morphology_sql_condition = MORPHOLOGY_TYPE_MAP[morphology_choice]['sql_condition']

            # Combine galaxy type and morphology conditions
            combined_where_clause = f"type = 3 AND {morphology_sql_condition}"
        else: # For Stars, QSOs, or All, just use the object type condition
            combined_where_clause = object_type_sql_condition

        while True:
            try:
                num_items = int(input("🔢 How many images do you want to download? (e.g., 100): "))
                if num_items > 0: break
                else: print("❌ Number of images must be positive.")
            except ValueError:
                print("❌ Invalid input. Please enter a valid number.")

        # Construct the SQL query automatically for image coordinates
        generated_sql_query_for_images = f"SELECT TOP {num_items} ra, dec FROM PhotoObj WHERE {combined_where_clause}"
        print(f"\nConstructed SQL Query for coordinates: {generated_sql_query_for_images}") # Show the generated query for transparency

        print("📡 Fetching coordinates from SDSS SkyServer...")
        coords_table = get_sdss_catalog_data_req(generated_sql_query_for_images)

        if coords_table is None or 'ra' not in coords_table.colnames or 'dec' not in coords_table.colnames:
            print("❌ Failed to retrieve valid RA/DEC coordinates from the generated query.")
            print("This might happen if your query returned no results for the selected criteria.")
            return # Exit if coordinates cannot be fetched

        ra_decs_list = [(row['ra'], row['dec']) for row in coords_table]
        if not ra_decs_list:
            print("⚠️ Your selection returned no results. No images to download.")
            return

        print(f"✅ Found {len(ra_decs_list)} sets of RA/DEC coordinates.")

        while True:
            try:
                image_size = int(input(f"📐 Image size in pixels (e.g., {DEFAULT_IMAGE_SIZE}): "))
                if image_size > 0: break
                else: print("❌ Image size must be positive.")
            except ValueError:
                print("❌ Invalid input. Please enter a valid number.")

        image_band = input(f"🔬 SDSS Band ({'/'.join(SUPPORTED_IMAGE_BANDS)}) [default: {DEFAULT_IMAGE_BAND}]: ").strip().lower() or DEFAULT_IMAGE_BAND
        while image_band not in SUPPORTED_IMAGE_BANDS:
            print(f"❌ Invalid band. Please enter one of: {', '.join(SUPPORTED_IMAGE_BANDS)}.")
            image_band = input(f"🔬 SDSS Band ({'/'.join(SUPPORTED_IMAGE_BANDS)}) [default: {DEFAULT_IMAGE_BAND}]: ").strip().lower() or DEFAULT_IMAGE_BAND

        print("📦 Save format for images:")
        print("1=PNG | 2=FITS | 3=Both")
        while True:
            try:
                output_format_choice = int(input("Enter your choice (1, 2, or 3): ").strip())
                if output_format_choice in [1, 2, 3]: break
                else: print("❌ Invalid input. Please enter 1, 2, or 3.")
            except ValueError:
                print("❌ Invalid input. Please enter a valid number.")

    elif data_type_choice == '2': # Spectra
        while True:
            try:
                plate = int(input("🔢 Enter Plate number (e.g., 2000): "))
                if plate > 0: break
                else: print("❌ Plate number must be positive.")
            except ValueError:
                print("❌ Invalid input. Please enter a valid number.")

        while True:
            try:
                mjd = int(input("📅 Enter MJD (Modified Julian Date, e.g., 53400): "))
                if mjd > 0: break
                else: print("❌ MJD must be positive.")
            except ValueError:
                print("❌ Invalid input. Please enter a valid number.")

        while True:
            try:
                fiberid = int(input("🧵 Enter Fiber ID (e.g., 100): "))
                if fiberid >= 0: break # Fiber ID can be 0 or positive
                else: print("❌ Fiber ID must be non-negative.")
            except ValueError:
                print("❌ Invalid input. Please enter a valid number.")

        output_format_choice = 2 # Spectra are always saved as FITS in this context
        print("📦 Spectra will be saved in FITS format automatically.")

    elif data_type_choice == '3': # Catalog Data
        print("\n📚 What kind of catalog data do you want to download?")
        for key, val in CATALOG_DATA_MAP.items():
            print(f"{key}. {val['name']}")

        catalog_type_choice = ""
        while catalog_type_choice not in CATALOG_DATA_MAP:
            catalog_type_choice = input(f"Enter your choice ({'/'.join(CATALOG_DATA_MAP.keys())}): ").strip()
            if catalog_type_choice not in CATALOG_DATA_MAP:
                print(f"❌ Invalid input. Please enter one of: {', '.join(CATALOG_DATA_MAP.keys())}.")

        if catalog_type_choice == '4': # Custom SQL Query
            catalog_sql_query = input(
                "📝 Enter your **custom SQL query** for SkyServer. "
                "This query should return the specific catalog data you need.\n"
                "Example: SELECT TOP 10 objid, ra, dec, z FROM SpecObj\n"
                "SQL Query: "
            ).strip()
            while not catalog_sql_query:
                print("❌ SQL query cannot be empty. Please enter a query.")
                catalog_sql_query = input("SQL Query: ").strip()
        else: # Simplified choices
            selected_catalog_info = CATALOG_DATA_MAP[catalog_type_choice]

            while True:
                try:
                    num_items = int(input(f"🔢 How many {selected_catalog_info['name'].lower()} do you want to download? (e.g., 1000): "))
                    if num_items > 0: break
                    else: print("❌ Number of items must be positive.")
                except ValueError:
                    print("❌ Invalid input. Please enter a valid number.")

            catalog_sql_query = f"SELECT TOP {num_items} {selected_catalog_info['columns']} FROM {selected_catalog_info['table']}"
            if selected_catalog_info['where']:
                catalog_sql_query += f" WHERE {selected_catalog_info['where']}"

            print(f"\nConstructed SQL Query: {catalog_sql_query}") # Show the generated query for transparency


        print("📦 Save format for catalog data:")
        print("1=CSV | 2=FITS | 3=JSON")
        while True:
            try:
                output_format_choice = int(input("Enter your choice (1, 2, or 3): ").strip())
                if output_format_choice in [1, 2, 3]: break
                else: print("❌ Invalid input. Please enter 1, 2, or 3.")
            except ValueError:
                print("❌ Invalid input. Please enter a valid number.")

    else: # This case should ideally not be reached due to input validation
        print("❌ An unexpected error occurred with data type selection. Exiting.")
        return

    # --- Step 3: Get Storage Parameters ---
    print("\n--- Step 3: Choose Storage Location ---")
    folder_name = input("📁 Enter folder name or full path where files will be saved (e.g., sdss_downloads): ").strip()
    while not folder_name: # Ensure folder name is not empty
        print("❌ Folder name cannot be empty. Please enter a valid folder name.")
        folder_name = input("📁 Enter folder name or full path: ").strip()

    print("📂 Where do you want to save the data?")
    print("1. Colab /content (temporary, available during session)")
    print("2. Google Drive (requires mounting, persistent) " + ("- Colab only" if COLAB_ENV else "(Unavailable)"))
    print("3. Custom local path (where this script is run, persistent)")
    if COLAB_ENV:
        print("4. Direct Download (downloads to your local machine) - Colab only")

    valid_dest_choices = ['1', '3']
    if COLAB_ENV:
        valid_dest_choices.extend(['2', '4'])

    dest_choice = ""
    while dest_choice not in valid_dest_choices:
        dest_choice = input("Enter your choice (" + ", ".join(valid_dest_choices) + "): ").strip()
        if dest_choice not in valid_dest_choices:
            print("❌ Invalid input. Please enter a valid choice.")

    # Variable to hold data for single item download/save (spectrum, catalog)
    download_item_data = None
    download_item_filename = ""

    # --- Fetch Data Before Saving/Downloading (for single items: Spectrum or Catalog) ---
    # Image fetching happens in a loop within `download_images_to_path`.
    if data_type_choice == '2': # Spectra
        print(f"📡 Preparing Spectrum for Plate={plate}, MJD={mjd}, FiberID={fiberid}...")
        download_item_data = get_sdss_spectrum_req(plate, mjd, fiberid)
        if download_item_data is None:
            print("❌ Failed to retrieve spectrum data. Cannot save/download.")
            return # Exit if data retrieval failed
        download_item_filename = f"spectrum_{plate}-{mjd}-{fiberid}.fits"

    elif data_type_choice == '3': # Catalog Data
        print(f"📡 Preparing Catalog Data with SQL Query: {catalog_sql_query}...")
        catalog_table = get_sdss_catalog_data_req(catalog_sql_query)
        if catalog_table is None:
            print("❌ Failed to retrieve catalog data. Cannot save/download.")
            return # Exit if data retrieval failed

        download_filename_base = "catalog_data"
        if output_format_choice == 1: # CSV
            download_item_data = catalog_table # Pass the Table object
            download_item_filename = f"{download_filename_base}.csv"
        elif output_format_choice == 2: # FITS
            download_item_data = catalog_table # Pass the Table object
            download_item_filename = f"{download_filename_base}.fits"
        elif output_format_choice == 3: # JSON
            try:
                # Convert Astropy Table to Pandas DataFrame then to JSON string and finally bytes
                download_item_data = json.dumps(catalog_table.to_pandas().to_dict(orient='records'), ensure_ascii=False, indent=4).encode('utf-8')
                download_item_filename = f"{download_filename_base}.json"
            except ImportError:
                print("⚠️ Pandas not found. Cannot convert to JSON. Saving as CSV instead.")
                download_item_data = catalog_table
                download_item_filename = f"{download_filename_base}.csv"
                output_format_choice = 1 # Force CSV format for saving logic
        else:
            print("❌ Invalid format choice for catalog data. Cannot save/download.")
            return # Should be caught by input validation, but good safeguard

    # --- Execute Save/Download ---
    print("\n🚀 Executing save/download process...")
    success_count = 0
    final_save_base_path = "" # To report the final base directory to the user

    if dest_choice == '1': # Colab /content
        final_save_base_path = f"/content/{folder_name}"
        os.makedirs(final_save_base_path, exist_ok=True)
        print(f"\n✅ Saving data to: {final_save_base_path}")
        if data_type_choice == '1': # Images
            success_count = download_images_to_path(ra_decs_list, image_band, image_size, output_format_choice, final_save_base_path)
        else: # Spectra or Catalog
            success_count = save_single_item(download_item_data, download_item_filename, final_save_base_path, data_type_choice, output_format_choice)

    elif dest_choice == '2': # Google Drive
        if not COLAB_ENV:
            print("❌ Google Drive option requires Colab environment. Falling back to Colab /content.")
            final_save_base_path = f"/content/{folder_name}"
            os.makedirs(final_save_base_path, exist_ok=True)
            print(f"\n✅ Saving data to: {final_save_base_path}")
            if data_type_choice == '1': success_count = download_images_to_path(ra_decs_list, image_band, image_size, output_format_choice, final_save_base_path)
            else: success_count = save_single_item(download_item_data, download_item_filename, final_save_base_path, data_type_choice, output_format_choice)
        else: # Attempt to mount and save to GDrive
            try:
                # Check if drive is already mounted to avoid redundant mounting prompts
                if not os.path.exists('/content/drive/My Drive'):
                    print("Mounting Google Drive...")
                    drive.mount('/content/drive', force_remount=True)
                else:
                    print("Google Drive already mounted.")

                final_save_base_path = f"/content/drive/MyDrive/{folder_name}"
                os.makedirs(final_save_base_path, exist_ok=True)
                print(f"\n✅ Saving data to: {final_save_base_path}")
                if data_type_choice == '1': # Images
                    success_count = download_images_to_path(ra_decs_list, image_band, image_size, output_format_choice, final_save_base_path)
                else: # Spectra or Catalog
                    success_count = save_single_item(download_item_data, download_item_filename, final_save_base_path, data_type_choice, output_format_choice)
            except Exception as e:
                print(f"⚠️ Error mounting or saving to Google Drive: {e}")
                print("⚠️ Falling back to Colab /content to save data.")
                final_save_base_path = f"/content/{folder_name}"
                os.makedirs(final_save_base_path, exist_ok=True)
                print(f"\n✅ Saving data to: {final_save_base_path}")
                if data_type_choice == '1': success_count = download_images_to_path(ra_decs_list, image_band, image_size, output_format_choice, final_save_base_path)
                else: success_count = save_single_item(download_item_data, download_item_filename, final_save_base_path, data_type_choice, output_format_choice)

    elif dest_choice == '3': # Custom local path (where the script is run)
        final_save_base_path = folder_name
        os.makedirs(final_save_base_path, exist_ok=True)
        print(f"\n✅ Saving data to: {final_save_base_path}")
        if data_type_choice == '1': # Images
            success_count = download_images_to_path(ra_decs_list, image_band, image_size, output_format_choice, final_save_base_path)
        else: # Spectra or Catalog
            success_count = save_single_item(download_item_data, download_item_filename, final_save_base_path, data_type_choice, output_format_choice)

    elif dest_choice == '4': # Direct Download (Colab only)
        if not COLAB_ENV:
            print("❌ Direct download option requires Colab environment. Falling back to Colab /content.")
            final_save_base_path = f"/content/{folder_name}"
            os.makedirs(final_save_base_path, exist_ok=True)
            print(f"\n✅ Saving data to: {final_save_base_path}")
            if data_type_choice == '1': success_count = download_images_to_path(ra_decs_list, image_band, image_size, output_format_choice, final_save_base_path)
            else: success_count = save_single_item(download_item_data, download_item_filename, final_save_base_path, data_type_choice, output_format_choice)
        else: # Attempt direct download
            # Direct download is primarily for single files.
            # For images, we'll download to /content first and then offer to download the zip.
            if data_type_choice == '1': # Images
                print("📦 For direct download of multiple images, they will first be saved to a temporary folder and then zipped.")
                temp_path = f"/content/{folder_name}_temp"
                os.makedirs(temp_path, exist_ok=True)
                success_count = download_images_to_path(ra_decs_list, image_band, image_size, output_format_choice, temp_path)
                if success_count > 0:
                    try:
                        zip_filename = f"{folder_name}_sdss_images.zip"
                        # Use shell command for zipping in Colab
                        os.system(f"zip -r {zip_filename} {temp_path}")
                        files.download(zip_filename)
                        print(f"✅ Zipped images downloaded as {zip_filename} to your local machine.")
                    except Exception as e:
                        print(f"⚠️ Error zipping or direct downloading images: {e}")
                        print("Consider saving to Google Drive or Colab /content instead.")
                    os.system(f"rm -rf {temp_path}") # Clean up temporary folder
                    os.system(f"rm -f {zip_filename}") # Clean up the zip file
            else: # Spectra or Catalog (single items)
                # Save temporarily to /content for direct download
                temp_path = "/content/temp_single_download"
                os.makedirs(temp_path, exist_ok=True)
                if save_single_item(download_item_data, download_item_filename, temp_path, data_type_choice, output_format_choice):
                    try:
                        files.download(os.path.join(temp_path, download_item_filename))
                        print(f"✅ {download_item_filename} downloaded to your local machine.")
                    except Exception as e:
                        print(f"⚠️ Error direct downloading {download_item_filename}: {e}")
                        print("Consider saving to Google Drive or Colab /content instead.")
                os.system(f"rm -rf {temp_path}") # Clean up temporary folder
                success_count = 1 if download_item_data else 0 # Mark as success if data was available


    if success_count > 0:
        if data_type_choice == '1':
            print(f"\n✨ Operation Complete: Successfully processed {success_count} image(s).")
        else:
            print(f"\n✨ Operation Complete: Successfully processed {success_count} item(s) ({'spectrum' if data_type_choice == '2' else 'catalog data'}).")

        if dest_choice != '4': # Don't tell them where to find it if it was a direct download
            print(f"You can find your downloaded data in the folder: {final_save_base_path}")
    else:
        print("\n❌ Operation Finished: No data was successfully downloaded.")

if __name__ == "__main__":
    main()

